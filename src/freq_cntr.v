//---------------------------------------------------------------------------//
//
// Copyright (C) 2018 Fidus Systems Inc.
// 
// Filename    : freq_cntr.v
// Project     : -
// Author      : Kevin Eckstrand
// Created     : Apr 19, 2018
// Description : This module reports the frequency of an incoming clock. It
//               is based on the 1PPM signal generated by a control clock.
//               Contains the following sub-modules:
//                 xpm_cdc_array_single  (XPM)
//                 xpm_cdc_single  (XPM)
//               
//---------------------------------------------------------------------------//

module freq_cntr #(
    parameter   pPPS_CNT_VALUE   = 100000000
) (  // system clock & resets
   input  wire          i_clk,
   input  wire          i_rst,
   // clock to measure
   input  wire          i_varclk,
   // measured frequency   (i_clk domain)
   output wire [31:0]   o_clkval
);


///////////////////////////////////////////////////////////////////////////////////////////
//   Signal declarations
///////////////////////////////////////////////////////////////////////////////////////////

// i_varclk domain
reg  [31:0] varclk_cntr = 32'h1;  // start at 1 to give natural number count
reg  [31:0] varclk_cntr_latch = 32'h0;
wire        pps_tog_s;
reg         pps_tog_s_dly = 1'b0;
reg         pps_trig = 1'b0;
reg         varclk_cntr_tog = 1'b0;

// i_clk domain
reg  [31:0] pps_cntr = 32'h0;
reg         pps_tog = 1'b0;
reg         pps_tog_dly = 1'b0;
wire        varclk_cntr_tog_s;
reg         varclk_cntr_tog_s_dly = 1'b0;
reg         store_varclk_cntr = 1'b0;
wire [31:0] varclk_cntr_latch_s;
reg  [31:0] clkval_next = 32'h0;
reg  [31:0] clkval = 32'h0;


///////////////////////////////////////////////////////////////////////////////////////////
//   Sync
///////////////////////////////////////////////////////////////////////////////////////////

// reporting only (non-critical application), no need for bus array handshaking
xpm_cdc_array_single #(
   .DEST_SYNC_FF   (2),
   .SIM_ASSERT_CHK (0),
   .SRC_INPUT_REG  (0),
   .WIDTH          (32)
) varclk_cntr_latch_sync_inst (
   .dest_clk ( i_clk                ),
   .src_in   ( varclk_cntr_latch    ),
   .dest_out ( varclk_cntr_latch_s  )
);

xpm_cdc_single #(
   .DEST_SYNC_FF   (2),
   .SIM_ASSERT_CHK (0),
   .SRC_INPUT_REG  (0)
) pps_tog_sync_inst (
   .dest_clk ( i_varclk   ),
   .src_in   ( pps_tog    ),
   .dest_out ( pps_tog_s  )
);

xpm_cdc_single #(
   .DEST_SYNC_FF   (8),
   .SIM_ASSERT_CHK (0),
   .SRC_INPUT_REG  (0)
) varclk_cntr_tog_sync_inst (
   .dest_clk ( i_clk   ),
   .src_in   ( varclk_cntr_tog    ),
   .dest_out ( varclk_cntr_tog_s  )
);


///////////////////////////////////////////////////////////////////////////////////////////
//   Main logic
///////////////////////////////////////////////////////////////////////////////////////////

// PPS counter & indicator
always @(posedge i_clk) begin
   if (i_rst) begin
      pps_cntr <= 32'h0;
      pps_tog <= 1'b0;
   end else begin
      if (pps_cntr < pPPS_CNT_VALUE-1) begin
         pps_cntr <= pps_cntr + 1'b1;
      end else begin
         pps_cntr <= 32'h0;
         pps_tog <= ~pps_tog;
      end
   end
end

// latch in updated counter value, clear outputs if no pulse received (indicating no clock)
always @(posedge i_clk) begin
   pps_tog_dly <= pps_tog;
   varclk_cntr_tog_s_dly <= varclk_cntr_tog_s;
   if (pps_tog_dly != pps_tog) begin
      clkval <= clkval_next;
      clkval_next <= 32'h0;
   end else if (varclk_cntr_tog_s_dly != varclk_cntr_tog_s) begin
      clkval_next <= varclk_cntr_latch_s;
   end
end

assign o_clkval = clkval;

// variable clock counter & latching logic
always @(posedge i_varclk) begin
   pps_tog_s_dly <= pps_tog_s;
   pps_trig <= (pps_tog_s_dly != pps_tog_s);
   if (pps_trig) begin
      varclk_cntr_latch <= varclk_cntr;
      varclk_cntr <= 32'h1;                      // start at 1 to give natural number count
      varclk_cntr_tog <= ~varclk_cntr_tog;
   end else begin
      varclk_cntr <= varclk_cntr + 1'b1;
   end
end


endmodule


